import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { ATR, EMA, RSI, MACD, BollingerBands } from 'technicalindicators';

// Tipos de alertas
export const ALERT_TYPES = {
  BREAKOUT: 'breakout',
  BREAKDOWN: 'breakdown',
  VOLUME_SPIKE: 'volume_spike',
  RSI_OVERBOUGHT: 'rsi_overbought',
  RSI_OVERSOLD: 'rsi_oversold',
  MACD_SIGNAL: 'macd_signal',
  BB_SQUEEZE: 'bollinger_squeeze'
};

// Configuración de reglas de alertas
const ALERT_RULES = [
  {
    type: ALERT_TYPES.BREAKOUT,
    condition: (candle, indicators, context) => {
      const { bb, atr, volumeMA } = indicators;
      return candle.close > bb.upper && 
             candle.volume > volumeMA * 1.5 && 
             (candle.close - candle.open) > atr * 0.5;
    },
    severity: 'high',
    message: (symbol, candle) => `${symbol}: Breakout above Bollinger Upper Band at $${candle.close.toFixed(2)}`
  },
  {
    type: ALERT_TYPES.BREAKDOWN,
    condition: (candle, indicators, context) => {
      const { bb, atr, volumeMA } = indicators;
      return candle.close < bb.lower && 
             candle.volume > volumeMA * 1.5 && 
             (candle.open - candle.close) > atr * 0.5;
    },
    severity: 'high',
    message: (symbol, candle) => `${symbol}: Breakdown below Bollinger Lower Band at $${candle.close.toFixed(2)}`
  },
  {
    type: ALERT_TYPES.VOLUME_SPIKE,
    condition: (candle, indicators, context) => {
      const { volumeMA, atr } = indicators;
      const priceMove = Math.abs(candle.close - candle.open) / candle.open;
      return candle.volume > volumeMA * 3 && priceMove > atr / candle.close * 2;
    },
    severity: 'medium',
    message: (symbol, candle, indicators) => {
      const { volumeMA } = indicators;
      const multiplier = (candle.volume / volumeMA).toFixed(1);
      return `${symbol}: Volume spike (${multiplier}x average) with significant price movement`;
    }
  },
  {
    type: ALERT_TYPES.RSI_OVERBOUGHT,
    condition: (candle, indicators, context) => {
      const { rsi } = indicators;
      return rsi > 80 && context.previousRSI <= 80;
    },
    severity: 'medium',
    message: (symbol, candle, indicators) => `${symbol}: RSI Overbought (${indicators.rsi.toFixed(1)}) - Potential reversal`
  },
  {
    type: ALERT_TYPES.RSI_OVERSOLD,
    condition: (candle, indicators, context) => {
      const { rsi } = indicators;
      return rsi < 20 && context.previousRSI >= 20;
    },
    severity: 'medium',
    message: (symbol, candle, indicators) => `${symbol}: RSI Oversold (${indicators.rsi.toFixed(1)}) - Potential bounce`
  }
];

// Calcular indicadores técnicos
const calculateIndicators = (candles, period = 14) => {
  if (candles.length < period + 1) return null;

  const closes = candles.map(c => c.close);
  const highs = candles.map(c => c.high);
  const lows = candles.map(c => c.low);
  const volumes = candles.map(c => c.volume);

  try {
    // ATR (Average True Range)
    const atrValues = ATR.calculate({
      high: highs,
      low: lows,
      close: closes,
      period
    });

    // RSI
    const rsiValues = RSI.calculate({
      values: closes,
      period
    });

    // EMA 12 y 26
    const ema12 = EMA.calculate({ values: closes, period: 12 });
    const ema26 = EMA.calculate({ values: closes, period: 26 });

    // MACD
    const macdValues = MACD.calculate({
      values: closes,
      fastPeriod: 12,
      slowPeriod: 26,
      signalPeriod: 9,
      SimpleMAOscillator: false,
      SimpleMASignal: false
    });

    // Bollinger Bands
    const bbValues = BollingerBands.calculate({
      period: 20,
      values: closes,
      stdDev: 2
    });

    // Volume Moving Average
    const volumeMA = volumes.slice(-period).reduce((sum, v) => sum + v, 0) / period;

    // Obtener valores más recientes
    const currentIndex = candles.length - 1;
    const atr = atrValues[atrValues.length - 1] || 0;
    const rsi = rsiValues[rsiValues.length - 1] || 50;
    const bb = bbValues[bbValues.length - 1] || { upper: 0, middle: 0, lower: 0 };
    const macd = macdValues[macdValues.length - 1] || { MACD: 0, signal: 0, histogram: 0 };

    return {
      atr,
      rsi,
      bb,
      macd,
      volumeMA,
      ema12: ema12[ema12.length - 1] || 0,
      ema26: ema26[ema26.length - 1] || 0,
      // Series completas para gráficos
      series: {
        rsi: rsiValues,
        bb: bbValues,
        macd: macdValues,
        ema12,
        ema26
      }
    };
  } catch (error) {
    console.error('Error calculating indicators:', error);
    return null;
  }
};

// Store principal
export const useMarketStore = create(
  subscribeWithSelector((set, get) => ({
    // Estado
    candles: {}, // { [symbol]: candle[] }
    indicators: {}, // { [symbol]: indicators }
    alerts: [],
    audioEnabled: true,
    isStreaming: true,
    lastUpdate: {},
    alertThresholds: {}, // { [symbol]: threshold }
    
    // Configuración
    updateInterval: 5000, // 5 segundos
    maxCandles: 100,
    maxAlerts: 50,
    
    // Actions
    setCandles: (symbol, newCandles) => {
      const state = get();
      const limitedCandles = newCandles.slice(-state.maxCandles);
      
      set({
        candles: {
          ...state.candles,
          [symbol]: limitedCandles
        },
        lastUpdate: {
          ...state.lastUpdate,
          [symbol]: Date.now()
        }
      });
      
      // Calcular indicadores automáticamente
      get().calculateIndicators(symbol);
      
      // Ejecutar motor de alertas
      get().runAlertEngine(symbol);
    },
    
    calculateIndicators: (symbol) => {
      const state = get();
      const candles = state.candles[symbol];
      
      if (!candles || candles.length < 20) return;
      
      const indicators = calculateIndicators(candles);
      
      if (indicators) {
        set({
          indicators: {
            ...state.indicators,
            [symbol]: indicators
          }
        });
      }
    },
    
    runAlertEngine: (symbol) => {
      const state = get();
      const candles = state.candles[symbol];
      const indicators = state.indicators[symbol];
      
      if (!candles || !indicators || candles.length < 2) return;
      
      const currentCandle = candles[candles.length - 1];
      const previousCandle = candles[candles.length - 2];
      const previousIndicators = state.indicators[symbol + '_prev'] || {};
      
      // Context para las reglas
      const context = {
        previousRSI: previousIndicators.rsi || 50,
        previousPrice: previousCandle.close,
        timeOfDay: new Date().getHours(),
        volatility: indicators.atr / currentCandle.close
      };
      
      // Evaluar cada regla
      ALERT_RULES.forEach(rule => {
        try {
          if (rule.condition(currentCandle, indicators, context)) {
            const alertId = `${symbol}-${rule.type}-${Date.now()}`;
            
            // Verificar si no hay alerta similar reciente (throttling)
            const recentSimilar = state.alerts.find(alert => 
              alert.symbol === symbol && 
              alert.type === rule.type && 
              Date.now() - alert.timestamp < 30000 // 30 segundos
            );
            
            if (!recentSimilar) {
              const alert = {
                id: alertId,
                symbol,
                type: rule.type,
                severity: rule.severity,
                message: rule.message(symbol, currentCandle, indicators),
                price: currentCandle.close,
                timestamp: Date.now(),
                indicators: {
                  rsi: indicators.rsi,
                  atr: indicators.atr,
                  volume: currentCandle.volume,
                  volumeMA: indicators.volumeMA
                }
              };
              
              get().addAlert(alert);
            }
          }
        } catch (error) {
          console.error(`Error evaluating rule ${rule.type} for ${symbol}:`, error);
        }
      });
      
      // Guardar indicadores anteriores
      set({
        indicators: {
          ...state.indicators,
          [symbol + '_prev']: indicators
        }
      });
    },
    
    addAlert: (alert) => {
      const state = get();
      const newAlerts = [alert, ...state.alerts.slice(0, state.maxAlerts - 1)];
      
      set({ alerts: newAlerts });
      
      // Reproducir sonido si está habilitado
      if (state.audioEnabled) {
        get().playAlertSound(alert.type, alert.severity);
      }
    },
    
    clearAlerts: () => set({ alerts: [] }),
    
    removeAlert: (alertId) => {
      const state = get();
      set({
        alerts: state.alerts.filter(alert => alert.id !== alertId)
      });
    },
    
    setAudioEnabled: (enabled) => set({ audioEnabled: enabled }),
    
    setAlertThreshold: (symbol, threshold) => {
      const state = get();
      set({
        alertThresholds: {
          ...state.alertThresholds,
          [symbol]: threshold
        }
      });
    },
    
    // Sistema de audio mejorado
    playAlertSound: (type, severity) => {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const frequencies = {
          [ALERT_TYPES.BREAKOUT]: [880, 1100],
          [ALERT_TYPES.BREAKDOWN]: [440, 330],
          [ALERT_TYPES.VOLUME_SPIKE]: [660, 880, 1100],
          [ALERT_TYPES.RSI_OVERBOUGHT]: [550, 440],
          [ALERT_TYPES.RSI_OVERSOLD]: [330, 440],
          [ALERT_TYPES.MACD_SIGNAL]: [523, 659],
          [ALERT_TYPES.BB_SQUEEZE]: [392, 493]
        };
        
        const freqs = frequencies[type] || [440];
        const duration = severity === 'high' ? 0.6 : 0.4;
        const volume = severity === 'high' ? 0.15 : 0.1;
        
        freqs.forEach((freq, index) => {
          setTimeout(() => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            oscillator.type = severity === 'high' ? 'sawtooth' : 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
          }, index * 100);
        });
      } catch (error) {
        console.warn('Could not play alert sound:', error);
      }
    },
    
    // Getters computed
    getSymbolData: (symbol) => {
      const state = get();
      return {
        candles: state.candles[symbol] || [],
        indicators: state.indicators[symbol] || null,
        lastUpdate: state.lastUpdate[symbol] || null
      };
    },
    
    getAlertsBySymbol: (symbol) => {
      const state = get();
      return state.alerts.filter(alert => alert.symbol === symbol);
    },
    
    // Estadísticas
    getMarketOverview: () => {
      const state = get();
      const symbols = Object.keys(state.candles);
      
      return symbols.map(symbol => {
        const candles = state.candles[symbol];
        const indicators = state.indicators[symbol];
        
        if (!candles || candles.length === 0) return null;
        
        const current = candles[candles.length - 1];
        const previous = candles[candles.length - 2];
        const change = previous ? ((current.close - previous.close) / previous.close) * 100 : 0;
        
        return {
          symbol,
          price: current.close,
          change,
          volume: current.volume,
          rsi: indicators?.rsi || null,
          lastUpdate: state.lastUpdate[symbol]
        };
      }).filter(Boolean);
    }
  }))
);

// Hook para suscripciones a símbolos específicos
export const useSymbolData = (symbol) => {
  return useMarketStore(state => state.getSymbolData(symbol));
};

// Hook para alertas de un símbolo
export const useSymbolAlerts = (symbol) => {
  return useMarketStore(state => state.getAlertsBySymbol(symbol));
};

export default useMarketStore;
